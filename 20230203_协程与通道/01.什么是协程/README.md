# 并发,并行和协程
## 什么使协程
一个应用程序是运行在机器上的一个进程,进程是一个运行在自己内存地址空间里的独立执行体.一个进程由一个或多个操作系统线程组成,这些线程其实是共享同一个内存地址空间的一起工作的执行体.

几乎所有正式的程序都是多线程的,以便让用户或计算机不必等待,或者能够同时服务多个请求,或增加性能和吞吐量.

一个并发程序可以在一个处理器或内核上使用多个线程来执行任务,但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行.

并行是一种通过使用多处理器以提高速度的能力,所以并发程序可以是并行的,也可以不是

公认的,使用多线程的应用难以做到准确,最主要的问题是内存中的数据共享,它们会被多线程以无法预知的方式进行操作,导致一些无法重现或者随机的结果(称作`竞态`)

不要使用全局变量或者共享内存,它们会给你的代码在并发运算的时候带来危险
-

解决之道在于同步不同的线程,对数据加锁,这样同时就只有一个线程可以变更数据.go标准库`sync`中有一些工具用来在低级别的代码中实现加锁.

不过过去的软件开发经验告诉我们这会带来更高的复杂度,更容易使代码出错以及更低的性能,所以这个经典的方法明显不再适合现代多核/多处理器编程:
`thread-per-connection`模型不够有效

go更倾向于其他方式,在诸多比较合适的范式中,有个被称作`Communicating Sequential Processes（顺序通信处理）`还有一个叫做`message passing-model（消息传递）`

在go中应用程序并发处理的部分被称作`goroutine`它可以进行更有效的并发运算,在协程和操作系统线程之间并无一对一的关系,协程是根据一个或多个线程的可用性,映射在他们之上的;协程调度器在go运行时很好的完成了这个工作

协程工作在相同的地址空间中,所以共享内存的方式一定是同步的,这个可以使用`sync`包来实现,不过我们不鼓励这样做;go使用`channel`来同步协程

当系统调用阻塞协程时,其他协程会继续在其他线程上工作.协程的设计隐藏了许多线程创建和管理方面的复杂工作.

协程是轻量的,比线程更轻,它们痕迹非常不明显,使用4K的栈内存就可以在堆中创建它们,因为创建非常廉价,必要的时候可以轻松的创建并运行大量的协程.并且它们堆栈进行了分割,从而动态的增加内存的使用;栈的管理是自动的,但不是由垃圾回收器管理的,而是在协程退出后自动释放.

协程可以运行在多个操作系统线程之间,也可以运行在线程之内,让你可以很小的内存占用就可以处理大量的任务.由于操作系统线程上的协程时间片,可以使用少量的操作系统线程就能拥有任意多个提供服务的协程,而且go运行时可以聪明的意识到哪些协程被阻塞了,暂时搁置它们并处理其他协程.

存在2中方式:

1. 确定性(明确定义排序)
2. 非确定性(加锁/互斥从而定义排序)
go的协程和通道理所当然的支持确定性的并发方式

协程时通过使用关键字go调用一个函数或者方法来实现的,这样会在当前的计算过程中开始一个同时进行的函数,在相同的地址空间中并且分配了独立的栈比如`go sum(bigArray)`后台计算总和.

协程的栈会根据需要进行伸缩,不出现栈溢出,开发者不需要关心栈的大小,当协程结束的时候,它会静默退出;用来启动这个协程的函数不会得到任何的返回值

任何go程序都必须有`main()`函数也可以看做是一个协程,尽管它并没有通过go来启动,协程可以在程序初始化的过程中运行

在一个协程中,它需要进行非常密集的运算,你可以在运算循环中周期的使用`runtime.Gosched()`这会让出处理器,允许运行其他协程,它并不会使当前协程挂起,所以他会自动恢复运行.使用`Gosched()`可以使计算均匀分布,使通信不至于迟迟得不到响应

## 并发和并行的差异
go的并发原语提供了良好的并发设计基础,表达程序结构以便表示独立执行的动作,所以go的重点不在于执行并行的首要位置,并发程序可能使并行的,也可能不是.

并行的一种通过使用多处理器以提高速度的能力,但往往是,一个设计良好的并发程序在并行方面的表现也非常出色

在当前的运行时实现中,go默认没有并行指令,只有一个独立的核心或处理器被专门用于go程序,不论它启动了多少个协程,所以这些协程是`并发`运行的,但它们不是`并行`运行的;同一时间只有一个协程会处在运行状态

这个情况在以后可能会发生改变,不过届时,为了使你的程序可以使用多个核心运行.这时协程就真正的并行运行了,你必须使用`GOMAXPROCS`变量,这会告诉运行时有多少协程同时执行

并且只有gc编译器真正实现了协程,适当的把协程映射到操作系统线程,使用gccgo编译器,会为每一个协程创建操作系统线程

## 使用GOMAXPROCS
在gc编译器下必须设置GOMAXPROCS为一个大于默认值1的数值来允许运行时支持使用多于1的操作系统线程,所有的协程都会共享同一个线程除非将GOMAXPROCS设置为一个大于1的数.当gomaxprocs大于1时,会有一个现称此管理许多的线程.

通过gccgo编译器gomaxprocs有效的与运行中的协程数量相等.假设n是机器上处理器或者核心的数量,如果你设置环境变量GOMAXPROCS>=n或者执行`runtime.GOMAXPROCS(n)`接下来协程会被分割到n个处理器上.

更过的处理器并不意味着性能的线性提升,有这样要给经验法则,对于n个核心的情况设置gomaxprocs为n-1以获得最佳性能,也同样需要遵守这条规则:协程的数量`>1+gomaxprocs>1`

所以如果在某一时间只有一个协程在运行,不要设置gomaxprocs

还有一些通过实验观察到现象,在一台1颗cpu电脑上增加gomaxprocs到9会带来性能提升.在一台32核的机器上,设置gomaxprocs=8会达到最好的性能,测试环境中,更高的数值无法提升性能,如果设置一个很大的gomaxprocs只会带来轻微的性能下降;设置gomaxprocs=100使用top命核H选项看到只有7个活动的线程

增加gomaxprocs的数值对程序进行并发计算是有好处的

## 如何使用命令指定使用的核心数量
使用`flag`包
> var numCores = flag.Int("n", 2, "number of CPU cores to use")

在main()中
```
flag.Parse()
runtime.GOMAXPROCS(*numCores)
```

协程是独立的处理单元,一旦陆续启动一些协程,你无法确定他们是什么时候真正开始执行的,你的代码逻辑必须独立于协程调用的顺序

为了对比使用一个线程,连续调用的情况,移除go关键字,重新运行程序
```
//go
longWait()

//go
shortWait()
```

协程更有用的一个例子应该是在一个非常长的数组中查找一个元素

将数组分割为若干不重复的切片,然后给每一个切片启动一个协程进行查找计算,这样许多并行的协程可以用来进行查找任务,整体的查找时间会缩短

## go协程(goroutines)和协程(corotines)
- go协程意味着并行,协程一般来说不是这样的
- go协程通过通道来通信;协程通过让出和恢复操作来通信