# 错误处理与测试
Go没有像Java和.Net那样的异常机制,不能执行抛异常操作.但是有一套defer-panic-and-recover机制

go的设计者觉得`tyy/cath`机制的使用太泛滥了,而且从底层向更高的层级抛异常太耗费资源.他们给go设计的机制可以"捕捉"异常,但是更轻量,并且只应该作为最后的手段

go是怎么处理普通错误的呢?
通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值,如果返回nil,则没有错误发生,并且主调函数总数应该检查收到的错误

永远不要忽略错误,否则可能会导致程序崩溃!
- 

处理错误并且在函数发生错误的地方给用户返回错误信息;照这样处理就算真的出了问题,你的程序也能继续运行并且通知给用户.`panic and recover`是用来处理真正的异常而不是普通的错误.

库函数通常必须返回某种错误提示给主调函数

go检查和报告错误条件的惯有方式:

- 产生错误的函数会返回两个变量,一个值和一个错误码;如果后者是nil就是成功的,非nil就是发生了错误
- 为了防止发生错误时正在执行的函数被中止,在调用函数后必须检查错误

下面这段pack1包的代码func1测试了它的返回值
```
if value, err := pack1.Func1(param1); err != nil {
    fmt.Printf("Error %s in pack1.Func1 with parameter %v", err.Error(), param1)
    return    // or: return err
} else {
    // Process(value)
}
```