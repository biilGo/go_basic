# 协程的同步:关闭通道-测试阻塞的通道
通道可以被显示的关闭;尽管它们和文件不同;不必每次都关闭,只有在当需要告诉接收者不会再提供新的值的时候,才需要关闭通道.只有发送者需要关闭通道,接收者永远不会需要

第一个可以通过函数close来完成,这个将通道标记为无法通过发送操作`<-`接收更多的值,给已经关闭的通道发送或者再次关闭都会导致运行时的panic.在创建一个通道后使用defer语句是个不错的方法
```
ch := make(chan float64)
defer close(ch)
```

第二个问题可以使用逗号,ok操作符,用来检测通道是否被关闭.如果检测可以收到没有被阻塞:`v, ok := <-ch   // ok is true if v received value`

通常和if语句一起使用
```
if v, ok := <-ch; ok {
  process(v)
}
```

或者在for循环中接收的时候,当关闭或者阻塞的时候使用break
```
v, ok := <-ch
if !ok {
  break
}
process(v)
```

阻塞和生产者-消费者模式
2个协程经常是一个阻塞另外一个,如果程序工作在多核心的机器上,大部分时间只用到了一个处理器,可以通过使用带缓冲的通带来改善,比如,缓冲大小为100,迭代器在阻塞之前,至少可以从容器获得100个元素,如果消费者协程在独立的内核运行,就有可能让协程不会出现阻塞.

由于容器中元素的数量通常是已知的,需要让通道有足够的容量放置所有的元素,这样,迭代器就不会阻塞.然而,这实际上加倍了迭代器容器所需要的内存使用量,所以通道的容量是需要限制一下最大值.记录运行时间和性能测试可以帮助你找到最小的缓存容量带来的最好的性能